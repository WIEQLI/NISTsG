(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["RiemannHilbert`"];
HillNLS::usage="HillmKdV[q,n] gives the eigenvalues of the modified Zakharov-Shabat scattering (including continuous spectrum) problem with n Fourier modes using Hill's method.";
LocatePolesNLS::usage="LocatePoles[q,n] gives the true eigenvalues of the modified Zakharov-Shabat scattering problem.";
NLS::usage="mKdV[i][x,t] = {out,\[CapitalPhi],rhp1,rhp2,timestring} where out is the solution of mKdV, \[CapitalPhi] is the solution of the Riemann-Hilbert problem, rhp1 and rhp2 are the Riemann-Hilbert problems and timestring is the string of computation times.  This is done using the deformation in Region i.";
NLSAuto::usage="NLSAuto[x,t] returns the solution of the mKdV equation with deformation selected automagically.  Many things must be initialized.  Sample code:

	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFinitemKdV[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
	SetParams[.6,.1,10.^(-9),15,30];\[IndentingNewLine]h[k_]:=3/(1+Abs[k/2+1/3.2]^8);\[IndentingNewLine]Setrsamp[h];\[IndentingNewLine]Settimeflag[False];\[IndentingNewLine]\[Nu]=Getnu[];\[IndentingNewLine]\[Rho][k_]:=bb[k]/aa[k];
	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};

	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};
SetScatteringData[aa,bb,m\[Rho],LocatePoles[q,40]]"
Focusing::usage="Focusing[], switch to focusing mKdV";
Defocusing::usage="Defocusing[], switch to focusing mKdV";
SetScatteringData::usage="SetScatteringData[a,b,\[Rho],poles] or SetScatteringData[a,b,\[Rho],poles,normingConstants] sets the scattering data for the mKdV equation";
SetParams::usage="SetParams[\[Nu],rad,globalTol,smallN,bigN] sets the parameters for the rest of the code:
	\[Nu]: half of width of strip of analyticity
	rad: radius of soliton contours
	globalTol: contour truncation tolerance
	smallN: small number of collocation points
	bigN: big number of collocation points";
GetScatteringData::usage="GetScatteringData[] = {\[Rho],poles,normingConstants}";
ScatteringMatrixFiniteNLS::usage="ScatteringMatrixFinitemKdV[q,n,L] returns a function f[w] that produces an approximation of the scattering matrix at w. The parameter n indicates the number of collocation points and L sets the problem on [-L,L]
Sample code:
	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFinitemKdV[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
";
Getnu::usage="Getnu[] returns \[Nu]";
Setrsamp::usage="Setrsamp[h] sets a function that should be chosen so that that |\[Rho]| < h";
timestring::usage="A string updated by mKdV[i][x,t]
(x,t) 1) Construct: --time to construct rhp1-- 1) Solve: --time to solve rhp1-- 2) Construct: --time to construct rhp2-- 2) Solve: --time to solve rhp2--";
Settimeflag::usage="Settimeflag[bool] bool = True forces timestring to be printed each time mKdV[i][x,t] is called";
startift;
domainOutput;domainOutput2;
SmallTimeContour;test2;test1;Modk0;test3;test4;
ift;
\[CapitalPhi]t;
\[CapitalPhi]tin;
dom;
J;
Jadapt;
(*need to be careful about the visibility of the local variables*)
L;U;G;Q;Qn;M;P;
Grhp1;Grhp2;
Begin["Private`"];


Focusing[]:=Module[{},\[Lambda]=1];
Defocusing[]:=Module[{},\[Lambda]=-1];
SetScatteringData[aa_,bb_,rr_,ma_,mc_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
dom=Truncate[globalTol][{Log[\[Tau][#]]&,Line[{-el,el}],100}][[1]];
c=mc;
];
SetScatteringData[aa_,bb_,rr_,ma_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
If[ma!= {},
(*Print[Fun[h[#]&,Line[{-1,1}],10]];*)
dom=Truncate[globalTol][{Log[1+rsamp[#]^2]&,Line[{-el,el}],100}][[1]];
f1=Fun[aa[#]-1&,Line[{0,\[Infinity]}],4bigN];
f2=Fun[aa[#]-1&,Line[{-\[Infinity],0}],4 bigN];
df1=f1';
df2=f2';
da[k_]:=Cauchy[df1,k]+Cauchy[df2,k];
c={};
For[i=1,i<=Length[ma],i++,
c=Join[c,{Quiet[bb[ma[[i]]]]/da[ma[[i]]]}];(*compute norming constants*)
];
];
Print[c];
];
SetParams[nu_,rad1_,tol_,sN_,bN_]:=Module[{},
\[Nu]=nu; (*parameter for width of strip of analyticity*)
rad=rad1;
globalTol=tol;
smallN=sN;
bigN=bN;
];
GetScatteringData[]:=Module[{},{r,a,c}];
Getnu[]:=\[Nu];
Setrsamp[h_]:=Module[{},rsamp=h];
Settimeflag[h_]:=Module[{},timeflag=h];
SetN[x_]:=Module[{},bigN=x[[1]];smallN=x[[2]];];
expconst=1;
el=100;
bigN=20;
smallN=10;


CME[x_]:=Chop[x,$MachineEpsilon];
ScatteringMatrixFiniteNLS[q_,n_,el_]:=Module[{qf,qfb,Dm,Dmb,IIm,IImb,P,Pb,id,Q,R,Qb,Rb,DM,DMb,q\[Sigma]1,q\[Sigma]1b,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,rhs,A,Ab},
       qf=Fun[q,Line[{-el,0}],n];
qfb=Fun[q,Line[{0,el}],n];
Print[{qf//Values//First//Abs,qf//DCTPlot}];
(*show the value of the Fun q at very left end, used to verify wether el is large enough*)
(*DCTPlot shows the magnitude of chebyshev coefficients*)
Dm=DerivativeMatrix[qf];
Dmb=DerivativeMatrix[qfb];
IIm=ReduceDimensionIntegrateMatrix[qf];
IImb=(ReduceDimensionIntegrateMatrix[(qfb//ReverseOrientation)]//Transpose//Reverse//Transpose//Reverse);
id=IdentityMatrix[n];
Q = DiagonalMatrix[qf//Values];
R= -\[Lambda] DiagonalMatrix[qf//Values];    (*this need to be modified*)
Qb = DiagonalMatrix[qfb//Values];   
Rb = -\[Lambda] DiagonalMatrix[qfb//Values];
A=BlockMatrix[{{id,-IIm.Q},{-IIm.R,id}}];
Ab=BlockMatrix[{{id,-IImb.Qb},{-IImb.Rb,id}}];
J\[Sigma]3=BlockMatrix[{{0*id,0},{0,-2I IIm}}];
J\[Sigma]31=BlockMatrix[{{2I IIm,0},{0,0*id}}];
J\[Sigma]3b=BlockMatrix[{{0*id,0},{0,-2I IImb}}];
J\[Sigma]31b=BlockMatrix[{{2I IImb,0},{0,0*id}}];
Print["How are you!"];
ScatteringMatrixFiniteNLS[qf,qfb,A,Ab,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,IIm,IImb]];

ScatteringMatrixFiniteNLS[qf_,qfb_,A_,Ab_,J\[Sigma]3_,J\[Sigma]31_,J\[Sigma]3b_,J\[Sigma]31b_,IIm_,IImb_][w_]:=Module[{ans0,ans1,rhs,lhs,n,s1,s2,qb,q,r,rb},
q = qf//Values;
qb = qfb//Values;
r = -\[Lambda] q//Conjugate;
rb= -\[Lambda] qb//Conjugate;
n = q//Length;
lhs=A+ w*J\[Sigma]3;
Print["How are you!22"];
Print[n];
rhs = Join[ConstantArray[0.,n],IIm.r];
ans0 = LinearSolve[lhs//CME,rhs//CME];
lhs=A+w*J\[Sigma]31;
rhs=Join[IIm.q,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
s1={{ans0[[n]]+1,-ans1[[n]]},{ans0[[2n]],-ans1[[2n]]-1}};
lhs=Ab+ w*J\[Sigma]3b;
Off[LinearSolve::luc];
rhs = Join[ConstantArray[0.,n],IImb.rb];
ans0 = LinearSolve[lhs//CME,rhs//CME];
lhs=Ab+ w*J\[Sigma]31b;
rhs = Join[IImb.qb,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
On[LinearSolve::luc];
s2={{ans0[[1]]+1,ans1[[1]]},{ans0[[n+1]],ans1[[n+1]]+1}};
s1=Inverse[s2].s1
];


HillNLS[F_,n_]:=Module[{c2,c1,c0,f11,f12,zz,f02,f01,t,A,mu,L,P,fun},
Off[General::unfl];
Off[General::ovfl];
mu = .25;
L = Pi;
P =1;
f11[x_]:= 2I Cos[x/2]^2;
f12[x_]:=-2I Cos[x/2]^2;
zz[x_]:=ConstantArray[0.,Length[x]];
t[x_] := Tan[x/2];
f02[x_]:= -I F[t[x]];
f01[x_]:=-\[Lambda] I Conjugate[F[t[x]]];
fun= {{{zz,f11},{f02,zz}},{{f01,zz},{zz,f12}}};
A= Hill[mu,L,n,P,fun];
On[General::unfl];
On[General::ovfl];
Eigenvalues[Chop[A,$MachineEpsilon]]
];
LocatePolesNLS[F_,n_]:=Module[{eval,s,i,sys,vecs},
Off[General::unfl];
eval=HillNLS[F,n];
s = {};
For[i=1,i<=Length[eval],i++,
If[Im[eval[[i]]]>10^(-4)&& Abs[eval[[i]]]<30,
s=Join[s,{eval[[i]]}];
];
];
On[General::unfl];
Chop[s,$MachineEpsilon]
];


\[Theta][x_,t_][z_]:=2 I (2 t z^2+x z);
rb[k_]:=\[Lambda] cc[r[cc[k]]];
rbsamp[k_]:=\[Lambda] cc[rsamp[cc[k]]];
\[Tau]samp[k_]:=1+\[Lambda] rsamp[k]cc[rsamp[cc[k]]];


L[x_,t_][k_]:=({
 {1, 0},
 {r[k]/\[Tau][k] Exp[\[Theta][x,t][k]], 1}
});
Lsamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k]/\[Tau]samp[k] Exp[\[Theta][x,t][k]], 1}
});

Lin[x_,t_][k_]:=({
 {1, 0},
 {-(r[k]/\[Tau][k])Exp[\[Theta][x,t][k]], 1}
});
Linsamp[x_,t_][k_]:=({
 {1, 0},
 {-(rsamp[k]/\[Tau]samp[k])Exp[\[Theta][x,t][k]], 1}
});


U[x_,t_][k_]:=({
 {1, rb[k]/\[Tau][k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Uin[x_,t_][k_]:=({
 {1, -(rb[k]/\[Tau][k])Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Usamp[x_,t_][k_]:=({
 {1, rbsamp[k]/\[Tau]samp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Uinsamp[x_,t_][k_]:=({
 {1, -(rbsamp[k]/\[Tau]samp[k])Exp[-\[Theta][x,t][k]]},
 {0, 1}
});

DD[k_]:=({
 {\[Tau][k], 0},
 {0, 1/\[Tau][k]}
});

DDsamp[k_]:=({
 {\[Tau]samp[k], 0},
 {0, 1/\[Tau]samp[k]}
});

G[x_,t_][z_]:=({
 {1+r[z]rb[z], rb[z]Exp[-2 I (2 t z^2+x z)]},
 {r[z] Exp[2 I (2t z^2+ x z)], 1}
});
G[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});

Gsamp[x_,t_][z_]:=({
 {1+rsamp[z]rbsamp[z], rbsamp[z]Exp[-2 I (2 t z^2+x z)]},
 {rsamp[z] Exp[2 I (2 t z^2+ x z)], 1}
});
Gsamp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});


M[x_,t_][k_]:=({
 {1, rb[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Msamp[x_,t_][k_]:=({
 {1, rbsamp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Minv[x_,t_][k_]:=({
 {1, -rb[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Minvsamp[x_,t_][k_]:=({
 {1, -rbsamp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
P[x_,t_][k_]:=({
 {1, 0},
 {r[k] Exp[\[Theta][x,t][k]], 1}
});
Psamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k] Exp[\[Theta][x,t][k]], 1}
});

qq[x_,t_][k_]:=Module[{out,i},
out = 1;
For[i=1,i<=Length[a],i++,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
out = out*(k-a[[i]])/(k-Conjugate[a[[i]]]);
];
];
out];
Q[x_,t_][k_]:=({
 {qq[x,t][k], 0},
 {0, 1/qq[x,t][k]}
});
Q[x_,t_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});


J[0][x_,t_]:={{G[x,t][#]&,G[x,t][#]&},{Line[{-el,0}],Line[{0,el}]},{bigN,bigN}};
Jsamp[0][x_,t_]:={{Gsamp[x,t][#]&,Gsamp[x,t][#]&},{Line[{-el,0}],Line[{0,el}]},{bigN,bigN}};
Jadapt[0][x_,t_]:=Adapt[Jsamp[0][x,t],globalTol][J[0][x,t]];


Modk0[x_,t_]:=If[t < 10*$MachineEpsilon,-Sign[x]*el/2,-Sign[x]*Min[Abs[x/(4t)],el/2]];
(*initialization cell   and    +-modk0 in small time contour*)
SmallTimeContour[x_,t_]:={Line[{-el + I \[Nu],Sqrt[2]\[Nu] Exp[I 3 Pi/4]}](*U part1*),Line[{Sqrt[2]\[Nu] Exp[I 3 Pi/4],0}](*U part2*),
Line[{-el,0}](*D*),
Line[{-el - I \[Nu],Sqrt[2]\[Nu] Exp[I 5 Pi/4]}](*L part1*),
Line[{Sqrt[2]\[Nu] Exp[I 5 Pi/4],0}](*L part2*),
Line[{0,Sqrt[2]\[Nu] Exp[I Pi/4]}](*p part2*),
Line[{Sqrt[2]\[Nu] Exp[I Pi/4],I \[Nu] + el}](*p part 1 *),
Line[{0,Sqrt[2]\[Nu] Exp[-I Pi/4]}](*m part2*),
Line[{Sqrt[2]\[Nu] Exp[-I Pi/4],-I \[Nu] + el}]}(*m part 1 *);
(*This smallTimeContour is centered at the origin right now*) 
(*if t is small, return +-100
  if t is large, return smaller one of x/4t and 100
if t is too small x/t will be too far away and do not affect too much, therefore put the deformation at z=+-100 is ok
*)
J[1][x_,t_]:={{U[x,t][#]&,U[x,t][#]&,
DD[#]&,L[x,t][#]&,L[x,t][#]&,P[x,t][#]&,P[x,t][#]&,M[x,t][#]&,M[x,t][#]&}, SmallTimeContour[x,t] + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
Jsamp[1][x_,t_]:={{Usamp[x,t][#]&,Usamp[x,t][#]&, 
DDsamp[#]&,Lsamp[x,t][#]&,Lsamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&}, SmallTimeContour[x,t] + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
(* old code not useful, seems to create only parts need to be truncated
Jsamp[1][x_,t_]:=
If[Abs[K0[x,t]]<\[Infinity],{Join[Table[Psamp[x,t][#]&,{i,1,Length[c1[x,t]]}],Table[Msamp[x,t][#]&,{i,1,Length[c1[x,t]]}]],Join[c1[x,t],c1[x,t]//LineConjugate],Table[bigN,{i,1,2*Length[c1[x,t]]}]}
,
{{Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&},{Line[{-el ,0}+I \[Nu]],Line[{0,el}+I \[Nu]],Line[{-el ,0}-I \[Nu]],Line[{0 ,el}-I \[Nu]]},{bigN,bigN,bigN,bigN}}
];*)
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]];
(*Try to break the contour at z\[Equal]0
SmallTimeContour={Line[{-el + I \[Nu],Sqrt[2]\[Nu] Exp[I 3 Pi/4]}](*U part1*),Line[{Sqrt[2]\[Nu] Exp[I 3 Pi/4],0}](*U part2*),
Line[{-el,0}](*D*),
Line[{-el - I \[Nu],Sqrt[2]\[Nu] Exp[I 5 Pi/4]}](*L part1*),
Line[{Sqrt[2]\[Nu] Exp[I 5 Pi/4],0}](*L part2*),
Line[{0,Sqrt[2]\[Nu] Exp[I Pi/4]}](*p part2*),
Line[{Sqrt[2]\[Nu] Exp[I Pi/4],I \[Nu] + el}](*p part1*),
Line[{0,Sqrt[2]\[Nu] Exp[-I Pi/4]}](*m part2*),
Line[{Sqrt[2]\[Nu] Exp[-I Pi/4],-I \[Nu] + el}]}(*m part1*);
(*This smallTimeContour is centered at the origin right now*) 
Modk0[x_,t_]:=If[t < 10*$MachineEpsilon,-Sign[x]*el/2,-Sign[x]*Min[Abs[x/(4t)],el/2]];
(*if t is small, return +-100
  if t is large, return smaller one of x/4t and 100
if t is too small x/t will be too far away and do not affect too much, therefore put the deformation at z=+-100 is ok
*)

J[1][x_,t_]:={{U[x,t][#]&,U[x,t][#]&,
DD[#]&,L[x,t][#]&,L[x,t][#]&,P[x,t][#]&,P[x,t][#]&,M[x,t][#]&,M[x,t][#]&}, SmallTimeContour + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};

Jsamp[1][x_,t_]:={{Usamp[x,t][#]&,Usamp[x,t][#]&,
DDsamp[#]&,Lsamp[x,t][#]&,Lsamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&}, SmallTimeContour + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
(* old code not useful, seems to create only parts need to be truncated
Jsamp[1][x_,t_]:=
If[Abs[K0[x,t]]<\[Infinity],{Join[Table[Psamp[x,t][#]&,{i,1,Length[c1[x,t]]}],Table[Msamp[x,t][#]&,{i,1,Length[c1[x,t]]}]],Join[c1[x,t],c1[x,t]//LineConjugate],Table[bigN,{i,1,2*Length[c1[x,t]]}]}
,
{{Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&},{Line[{-el ,0}+I \[Nu]],Line[{0,el}+I \[Nu]],Line[{-el ,0}-I \[Nu]],Line[{0 ,el}-I \[Nu]]},{bigN,bigN,bigN,bigN}}
];*)
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]];*)


InvScale[x_,t_][k_]:=Sqrt[t](k+x/(4t));


T[+1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {-c Exp[\[Theta][x,t][a]]/(z-a), 1}
});
T[-1][x_,t_,a_,c_][z_]:=({
 {1, \[Lambda] cc[-c Exp[\[Theta][x,t][a]]/(cc[z]-a)]},
 { 0, 1}
});
S[+1][x_,t_,a_,c_][z_]:=({
 {1, -(z-a)/c*Exp[-\[Theta][x,t][a]]},
 {0, 1}
});
S[-1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {\[Lambda] cc[-(cc[z]-a)/c*Exp[-\[Theta][x,t][a]]], 1}
});
ContourArray[+1,r_,a_]:={Arc[a,r,{0,Pi}],Arc[a,r,{Pi,2Pi}]};
ContourArray[-1,r_,a_]:={Arc[a//cc,r,{0,-Pi}],Arc[a//cc,r,{-Pi,-2Pi}]};


(*changed PoleList to PoleListn, cause this is the one called in the Add Poles part*)
PoleListn[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[a],i++,
If[1/globalTol>Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]&&Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> globalTol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{S[+1][x,t,a[[i]],c[[i]]],S[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{S[-1][x,t,a[[i]],c[[i]]],S[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";,
Jumps = Join[Jumps,{T[+1][x,t,a[[i]],c[[i]]],T[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{T[-1][x,t,a[[i]],c[[i]]],T[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArray[+1,rad,a[[i]]],ContourArray[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];


DomainIntegrate[0.]:=0;
tcrit=8;
NLS[i_][x_,t_]:=Module[{rhp1,rhp2,scale,\[CapitalPhi]1,\[CapitalPhi]2,\[CapitalPhi],out,t1,t2,t3,t4,poles,pl},
If[i==2,scale=True,scale=False];
RHSolved//Clear;
RHSolved[X_]:=RHSolved[X]=RHSolve[X];
RHSolved[{}]:=0.;
RHSolution[X_][z_]:=Cauchy[X//RHSolved,z]+IdentityMatrix[2];
(*Q is V in the book*)
If[scale,
(*Scaled contour*)
t1=AbsoluteTiming[rhp1=ConjugateList[Jadapt[i][x,t],Q[x,t]]//MakeListFun;];
t2=AbsoluteTiming[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][InvScale[x,t][k]]//Inverse;
,
(*Unscaled contour*)
t1=Timing[rhp1=ConjugateList[Jadapt[i][x,t],Q[x,t]]//MakeListFun;];

domainOutput = DomainPlot[rhp1];
Grhp1=rhp1;
(*Print["rhp1 constructed"];*)
t2=Timing[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][k]//Inverse;
];
(*Print["rhp1 solved"];*)
rhp2= ConjugateList[PoleListn[x,t],Q[x,t]];
(*Print["checking polelist at x =",x,", t =",t," and PoleListn[x,t]=",PoleListn[x,t]];*)
Grhp2=rhp2;
(*pl is not given any value, \[CapitalPhi]tin is the delta in the book*)
If[i==2,
rhp2= ConjugateList[rhp2,\[CapitalPhi]tin[x,t]];
];
t3=Timing[rhp2= ConjugateList[rhp2,\[CapitalPhi]1]//MakeListFun;];
t4=Timing[RHSolved[rhp2];];
\[CapitalPhi]2 = RHSolution[rhp2];
\[CapitalPhi][k_]:=RHSolution[rhp2][k].RHSolution[rhp1][k];
out=-(DomainIntegrate[RHSolved[rhp1]]+DomainIntegrate[RHSolved[rhp2]])[[1,2]]/Pi;
(*domainOutput = DomainPlot[Join[rhp1,rhp2]]//Quiet;*)
domainOutput2 = DomainPlot[rhp2]//Quiet;
timestring= "Region: " <>ToString[i]<>" ("<>ToString[x]<>","<>ToString[t]<>") "<>"1) Construct: " <> ToString[t1//First]<>"  "<>"1) Solve: " <> ToString[t2//First]<>"  "<>"2) Construct: " <> ToString[t3//First]<>"  "<>"2) Solve: " <> ToString[t4//First];
If[timeflag,Print[timestring];];
{out,\[CapitalPhi],rhp1,rhp2,timestring}
];
NLSAuto[x_,t_]:=\[Piecewise]{
 {NLS[0][x,t][[1]], Abs[x]<=5&&t<.1},
 {NLS[2][x,t][[1]], t>tcrit},
 {NLS[1][x,t][[1]], True}
}



End[];
