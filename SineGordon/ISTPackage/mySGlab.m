(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["RiemannHilbert`"];
HillSG::usage="HillSG[q,n] gives the eigenvalues of the modified Zakharov-Shabat scattering (including continuous spectrum) problem with n Fourier modes using Hill's method.";
LocatePolesSG::usage="LocatePoles[q,n] gives the true eigenvalues of the modified Zakharov-Shabat scattering problem.";
SG::usage="mKdV[i][x,t] = {out,\[CapitalPhi],rhp1,rhp2,timestring} where out is the solution of mKdV, \[CapitalPhi] is the solution of the Riemann-Hilbert problem, rhp1 and rhp2 are the Riemann-Hilbert problems and timestring is the string of computation times.  This is done using the deformation in Region i.";
SGAuto::usage="NLSAuto[x,t] returns the solution of the mKdV equation with deformation selected automagically.  Many things must be initialized.  Sample code:

	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFinitemKdV[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
	SetParams[.6,.1,10.^(-9),15,30];\[IndentingNewLine]h[k_]:=3/(1+Abs[k/2+1/3.2]^8);\[IndentingNewLine]Setrsamp[h];\[IndentingNewLine]Settimeflag[False];\[IndentingNewLine]\[Nu]=Getnu[];\[IndentingNewLine]\[Rho][k_]:=bb[k]/aa[k];
	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};

	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};
SetScatteringData[aa,bb,m\[Rho],LocatePoles[q,40]]"

SetScatteringData::usage="SetScatteringData[a,b,\[Rho],poles] or SetScatteringData[a,b,\[Rho],poles,normingConstants] sets the scattering data for the mKdV equation";
SetParams::usage="SetParams[\[Nu],rad,globalTol,smallN,bigN] sets the parameters for the rest of the code:
	\[Nu]: half of width of strip of analyticity
	rad: radius of soliton contours
	globalTol: contour truncation tolerance
	smallN: small number of collocation points
	bigN: big number of collocation points";
GetScatteringData::usage="GetScatteringData[] = {\[Rho],poles,normingConstants}";
ScatteringMatrixFiniteSG::usage="ScatteringMatrixFinitemKdV[q,n,L] returns a function f[w] that produces an approximation of the scattering matrix at w. The parameter n indicates the number of collocation points and L sets the problem on [-L,L]
Sample code:
	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFinitemKdV[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
";
Getnu::usage="Getnu[] returns \[Nu]";
Setrsamp::usage="Setrsamp[h] sets a function that should be chosen so that that |\[Rho]| < h";
timestring::usage="A string updated by mKdV[i][x,t]
(x,t) 1) Construct: --time to construct rhp1-- 1) Solve: --time to solve rhp1-- 2) Construct: --time to construct rhp2-- 2) Solve: --time to solve rhp2--";
Settimeflag::usage="Settimeflag[bool] bool = True forces timestring to be printed each time mKdV[i][x,t] is called";
startift;
domainOutput;domainOutput2;
SmallTimeContour;test2;test1;Modk0;test3;test4;
ift1;ift2;
\[CapitalPhi]t;
\[CapitalPhi]tin;
dom;
J;
Jadapt;
(*need to be careful about the visibility of the local variables*)
L;U;G;Q;Qn;M;P;Msamp;Psamp;
Grhp1;Grhp2;illlhs;
Gsamp;
Begin["Private`"];


(*SetScatteringData[aa_,bb_,rr_,ma_,mc_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+ r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
dom=Truncate[globalTol][{Log[\[Tau][#]]&,Line[{-el,el}],100}][[1]];
c=mc;
];*)
SetScatteringData[aa_,bb_,rr_,rrb_,ma_]:=Module[{},
r[k_]:=rr[k];
(*rb[k_]:=rrb[cc[k]];*)
a=ma;
\[Tau][k_]:=1+r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
(*dom=Truncate[globalTol][{Log[1+rsamp[#]^2]&,Line[{-el,el}],100}][[1]];*)
c={};
If[ma!= {},
(*Print[Fun[h[#]&,Line[{-1,1}],10]];*)
f1=Fun[aa[#]-1&,Line[{0,\[Infinity]}],2bigN];
f2=Fun[aa[#]-1&,Line[{-\[Infinity],0}],2 bigN];
df1=f1';
df2=f2';
da[k_]:=Cauchy[df1,k]+Cauchy[df2,k];
For[i=1,i<=Length[ma],i++,
c=Join[c,{Quiet[bb[ma[[i]]]]/da[ma[[i]]]}];(*compute norming constants*)
];
];
c
];
SetParams[nu_,rad1_,tol_,sN_,bN_,eL_]:=Module[{},
\[Nu]=nu; (*parameter for width of strip of analyticity*)
rad=rad1;
globalTol=tol;
smallN=sN;
bigN=bN;
el=eL;
];
GetScatteringData[]:=Module[{},{r,a,c}];
Getnu[]:=\[Nu];
Setrsamp[h_]:=Module[{},rsamp=h];
Settimeflag[h_]:=Module[{},timeflag=h];
SetN[x_]:=Module[{},bigN=x[[1]];smallN=x[[2]];];
expconst=10;
(*bigN=20;
smallN=10;*)


CME[x_]:=Chop[x,$MachineEpsilon];
ScatteringMatrixFiniteSG[q_,qt_,n_,el_]:=Module[{qf,qtf,qxf,qfb,qtfb,qxfb,Dm,Dmb,IIm,IImb,id,DM,DMb,q\[Sigma]1,q\[Sigma]1b,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,rhs,A,Ab,xf,xfb},
       qf=Fun[q,Line[{-el,0}],n]; (*Forward scattering*)
qtf=Fun[qt,Line[{-el,0}],n];
qxf=qf';(*assume the diff is spectral*)
qfb=Fun[q,Line[{0,el}],n];
qtfb=Fun[qt,Line[{0,el}],n];
qxfb=qfb';
xf=Fun[#&,Line[{-el,0}],n];
xfb=Fun[#&,Line[{0,el}],n];
(*Print[{qf//Values//First//Abs,qf//DCTPlot,qfb//DCTPlot}];*)

Dm=DerivativeMatrix[qf];      (*this gives the chebyshev differentiation matrix*)
Dmb=DerivativeMatrix[qfb];  (*ie   Dm . Values[qf] = derivative of qf *)
IIm=ReduceDimensionIntegrateMatrix[qf];
IImb=(ReduceDimensionIntegrateMatrix[(qfb//ReverseOrientation)]//Transpose//Reverse//Transpose//Reverse);(*integrate in the opposite direction (value at x=el vanishes)*)
ScatteringMatrixFiniteSG[n,qf,qtf,qxf,qfb,qtfb,qxfb,IIm,IImb,xf,xfb]];


ScatteringMatrixFiniteSG[n_,qf_,qtf_,qxf_,qfb_,qtfb_,qxfb_,IIm_,IImb_,xf_,xfb_][w_]:=Module[{ans0,ans1,rhs,lhs,s1,s2,ss1,qb,q,r,rb,z,Q11,Q12,Q21,Q22,Qb11,Qb12,Qb21,Qb22,A,Ab,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,id,expzx,iexpzx,expzxb,iexpzxb},
illcond=False;
If [Abs[w]>1, (*Outside the unit circle use infinite gauge*)
id=IdentityMatrix[n];
z=(w-1/w)/4;
Q11 = DiagonalMatrix[(I/4/w*(Cos[qf]-1))  //Values];
Q12 = DiagonalMatrix[(I/4/w*Sin[qf]-1/4*(qtf+qxf))  //Values];
Q21 = DiagonalMatrix[(I/4/w*Sin[qf]+1/4*(qtf+qxf)) //Values];
Q22 = DiagonalMatrix[-(I/4/w*(Cos[qf]-1)) //Values];

Qb11 = DiagonalMatrix[(I/4/w*(Cos[qfb]-1))  //Values];
Qb12 = DiagonalMatrix[(I/4/w*Sin[qfb]-1/4*(qtfb+qxfb))  //Values];
Qb21 = DiagonalMatrix[(I/4/w*Sin[qfb]+1/4*(qtfb+qxfb)) //Values];
Qb22 = DiagonalMatrix[-(I/4/w*(Cos[qfb]-1)) //Values];

(*expzx=DiagonalMatrix[(Exp[2*I*z*xf])//Values];
iexpzx=DiagonalMatrix[(Exp[-2*I*z*xf])//Values]; (*inverse*)
expzxb=DiagonalMatrix[(Exp[2*I*z*xfb])//Values];
iexpzxb=DiagonalMatrix[(Exp[-2*I*z*xfb])//Values];*)

J\[Sigma]3=BlockMatrix[{{0*id,0},{0,-2I IIm}}];
J\[Sigma]31=BlockMatrix[{{2I IIm,0},{0,0*id}}];
J\[Sigma]3b=BlockMatrix[{{0*id,0},{0,-2I IImb}}];
J\[Sigma]31b=BlockMatrix[{{2I IImb,0},{0,0*id}}];
A=BlockMatrix[{{id-IIm.Q11,-IIm.Q12},{-IIm.Q21,id-IIm.Q22}}];
Ab=BlockMatrix[{{id-IImb.Qb11,-IImb.Qb12},{-IImb.Qb21,id-IImb.Qb22}}];

On[LinearSolve::luc];
lhs=A+ z*J\[Sigma]3;
rhs = Join[IIm.Diagonal[Q11],IIm.Diagonal[Q21]];
If[illcond,
Print["Linear solve 1 cond=",Max[SingularValueList[lhs,Tolerance->0]]/Min[SingularValueList[lhs,Tolerance->0]]]];
(*Print[SingularValueList[lhs//CME]];*)
illlhs=lhs;
ans0 = LinearSolve[lhs//CME,rhs//CME];

lhs=A+z*J\[Sigma]31;
rhs=Join[-IIm.Diagonal[Q12],-IIm.Diagonal[Q22]];
(*Print["Linear solve 2 cond=",Max[SingularValueList[lhs]]/Min[SingularValueList[lhs]]];*)ans1 = LinearSolve[lhs//CME,rhs//CME];

(*A=BlockMatrix[{{id-IIm.expzx.Q11.iexpzx,-IIm.expzx.Q12},{-IIm.Q21.iexpzx,id-IIm.Q22}}];
lhs=A;
rhs=Join[-IIm.expzx.Diagonal[Q12],-IIm.Diagonal[Q22]];
If[illcond,
Print["Linear solve 2 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
cond2=Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]];*)
s1={{ans0[[n]]+1,ans1[[n]]},{ans0[[2n]],ans1[[2n]]-1}};
(*ss1={{ans0[[n]]+1,-ans1[[n]]},{ans0[[2n]],-ans1[[2n]]-1}};*)
(*Print[s1,ss1];*)

(*Ab=BlockMatrix[{{id-IImb.Qb11,-IImb.Qb12},{-expzxb.IImb.iexpzxb.Qb21,id-expzxb.IImb.iexpzxb.Qb22}}];
lhs=Ab;
rhs = Join[IImb.Diagonal[Qb11],expzxb.IImb.iexpzxb.Diagonal[Qb21]];
Print["Linear solve 3 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]];
ans0 = LinearSolve[lhs//CME,rhs//CME];*)
(*combined exp*)
(*Ab=BlockMatrix[{{id-IImb.Qb11,-IImb.Qb12.expzxb},{-IImb.iexpzxb.Qb21,id-IImb.iexpzxb.Qb22.expzxb}}];
lhs=Ab;
rhs = Join[IImb.Diagonal[Qb11],IImb.iexpzxb.Diagonal[Qb21]];
If[illcond,
Print["Linear solve 3 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]]];
ans0 = LinearSolve[lhs//CME,rhs//CME];*)

Ab=BlockMatrix[{{id-IImb.Qb11,-IImb.Qb12},{-IImb.Qb21,id-IImb.Qb22}}];
lhs=Ab+ z*J\[Sigma]3b;
rhs = Join[IImb.Diagonal[Qb11],IImb.Diagonal[Qb21]];
(*Print["Linear solve 3 cond=",Max[SingularValueList[lhs]]/Min[SingularValueList[lhs]]];*)
ans0 = LinearSolve[lhs//CME,rhs//CME];

Ab=BlockMatrix[{{id-IImb.Qb11,-IImb.Qb12},{-IImb.Qb21,id-IImb.Qb22}}];
lhs=Ab+ z*J\[Sigma]31b;
rhs = Join[IImb.Diagonal[Qb12],IImb.Diagonal[Qb22]];
If[illcond,
Print["Linear solve 4 cond=",Max[SingularValueList[lhs,Tolerance->0]]/Min[SingularValueList[lhs,Tolerance->0]]]];
ans1 = LinearSolve[lhs//CME,rhs//CME];

On[LinearSolve::luc];

s2={{ans0[[1]]+1,ans1[[1]]},{ans0[[n+1]],ans1[[n+1]]+1}};
(*Print[Inverse[s2].s1,Inverse[s2].ss1];*)
If[illcond,
Print[s1]];
If[illcond,
Print[s2]];
s1=Inverse[s2].s1;
(*s1=({{s2[[2,2]],-s2[[1,2]]},{-s2[[2,1]],s2[[1,1]]}}/Det[s2]).s1;*)
,
(*inside unit circle*)

(*
(*Using exp integrator, but for z real goes to zero  it is not correct*)
z=(w-1/w)/4;
expzx=DiagonalMatrix[(Exp[2*I*z*xf])//Values];
iexpzx=DiagonalMatrix[(Exp[-2*I*z*xf])//Values];
expzxb=DiagonalMatrix[(Exp[2*I*z*xfb])//Values];
iexpzxb=DiagonalMatrix[(Exp[-2*I*z*xfb])//Values];

id=IdentityMatrix[n];
Q11 = DiagonalMatrix[(I/4*w*(Cos[qf]-1))  //Values];
Q12 = DiagonalMatrix[(-I/4*w*Sin[qf]-1/4*(qxf-qtf))  //Values];
Q21 = DiagonalMatrix[(-I/4*w*Sin[qf]+1/4*(qxf-qtf)) //Values];
Q22 = DiagonalMatrix[-(I/4*w*(Cos[qf]-1)) //Values];

Qb11 = DiagonalMatrix[(I/4*w*(Cos[qfb]-1))  //Values];
Qb12 = DiagonalMatrix[(-I/4*w*Sin[qfb]-1/4*(qxfb-qtfb))  //Values];
Qb21 = DiagonalMatrix[(-I/4*w*Sin[qfb]+1/4*(qxfb-qtfb)) //Values];
Qb22 = DiagonalMatrix[-(I/4*w*(Cos[qfb]-1)) //Values];

J\[Sigma]3=BlockMatrix[{{0*id,0},{0,-2I IIm}}];
J\[Sigma]31=BlockMatrix[{{2I IIm,0},{0,0*id}}];
J\[Sigma]3b=BlockMatrix[{{0*id,0},{0,-2I IImb}}];
J\[Sigma]31b=BlockMatrix[{{2I IImb,0},{0,0*id}}];
A=BlockMatrix[{{id+IIm.Q11,+IIm.Q12},{+IIm.Q21,id+IIm.Q22}}];
Ab=BlockMatrix[{{id+IImb.Qb11,+IImb.Qb12},{+IImb.Qb21,id+IImb.Qb22}}];


On[LinearSolve::luc];
lhs=A+ z*J\[Sigma]3;
rhs = Join[-IIm.Diagonal[Q11],-IIm.Diagonal[Q21]];
If[illcond,
Print["Linear solve 1 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]]];
(*Print[SingularValueList[lhs//CME]];*)
illlhs=lhs;
ans0 = LinearSolve[lhs//CME,rhs//CME];

A=BlockMatrix[{{id+iexpzx.IIm.expzx.Q11,+iexpzx.IIm.expzx.Q12},{+IIm.Q21,id+IIm.Q22}}];
lhs=A;
rhs=Join[+iexpzx.IIm.expzx.Diagonal[Q12],+IIm.Diagonal[Q22]];
If[illcond,
Print["Linear solve 2 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
cond2=Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]];

s1={{ans0[[n]]+1,ans1[[n]]},{ans0[[2n]],ans1[[2n]]-1}};
(*ss1={{ans0[[n]]+1,-ans1[[n]]},{ans0[[2n]],-ans1[[2n]]-1}};*)
(*Print[s1,ss1];*)
Ab=BlockMatrix[{{id+IImb.Qb11,+IImb.Qb12},{+expzxb.IImb.iexpzxb.Qb21,id+expzxb.IImb.iexpzxb.Qb22}}];
lhs=Ab;
rhs = Join[-IImb.Diagonal[Qb11],-expzxb.IImb.iexpzxb.Diagonal[Qb21]];
If[illcond,
Print["Linear solve 3 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]]];
ans0 = LinearSolve[lhs//CME,rhs//CME];

Ab=BlockMatrix[{{id+IImb.Qb11,+IImb.Qb12},{+IImb.Qb21,id+IImb.Qb22}}];
lhs=Ab+ z*J\[Sigma]31b;
rhs = Join[-IImb.Diagonal[Qb12],-IImb.Diagonal[Qb22]];
If[illcond,
Print["Linear solve 4 cond=",Max[SingularValueList[lhs,Tolerance\[Rule]0]]/Min[SingularValueList[lhs,Tolerance\[Rule]0]]]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
*)

(*v2 just use zero gauge*)

z=(w-1/w)/4;
id=IdentityMatrix[n];
Q11 = DiagonalMatrix[(I/4*w*(Cos[qf]-1))  //Values];
Q12 = DiagonalMatrix[(-I/4*w*Sin[qf]-1/4*(qxf-qtf))  //Values];
Q21 = DiagonalMatrix[(-I/4*w*Sin[qf]+1/4*(qxf-qtf)) //Values];
Q22 = DiagonalMatrix[-(I/4*w*(Cos[qf]-1)) //Values];

Qb11 = DiagonalMatrix[(I/4*w*(Cos[qfb]-1))  //Values];
Qb12 = DiagonalMatrix[(-I/4*w*Sin[qfb]-1/4*(qxfb-qtfb))  //Values];
Qb21 = DiagonalMatrix[(-I/4*w*Sin[qfb]+1/4*(qxfb-qtfb)) //Values];
Qb22 = DiagonalMatrix[-(I/4*w*(Cos[qfb]-1)) //Values];

J\[Sigma]3=BlockMatrix[{{0*id,0},{0,-2I IIm}}];
J\[Sigma]31=BlockMatrix[{{2I IIm,0},{0,0*id}}];
J\[Sigma]3b=BlockMatrix[{{0*id,0},{0,-2I IImb}}];
J\[Sigma]31b=BlockMatrix[{{2I IImb,0},{0,0*id}}];
A=BlockMatrix[{{id+IIm.Q11,+IIm.Q12},{+IIm.Q21,id+IIm.Q22}}];
Ab=BlockMatrix[{{id+IImb.Qb11,+IImb.Qb12},{+IImb.Qb21,id+IImb.Qb22}}];

On[LinearSolve::luc];
lhs=A+ z*J\[Sigma]3;
rhs = Join[-IIm.Diagonal[Q11],-IIm.Diagonal[Q21]];
If[illcond,
Print["Linear solve 1 cond=",Max[SingularValueList[lhs,Tolerance->0]]/Min[SingularValueList[lhs,Tolerance->0]]];];
(*Print[SingularValueList[lhs//CME]];*)
illlhs=lhs;
ans0 = LinearSolve[lhs//CME,rhs//CME];

lhs=A+ z*J\[Sigma]31;
rhs = Join[IIm.Diagonal[Q12],IIm.Diagonal[Q22]];
If[illcond,
Print["Linear solve 2 cond=",Max[SingularValueList[lhs,Tolerance->0]]/Min[SingularValueList[lhs,Tolerance->0]]];];
ans1 = LinearSolve[lhs//CME,rhs//CME];

s1={{ans0[[n]]+1,ans1[[n]]},{ans0[[2n]],ans1[[2n]]-1}};
(*ss1={{ans0[[n]]+1,-ans1[[n]]},{ans0[[2n]],-ans1[[2n]]-1}};*)
(*Print[s1,ss1];*)

Ab=BlockMatrix[{{id+IImb.Qb11,+IImb.Qb12},{+IImb.Qb21,id+IImb.Qb22}}];
lhs=Ab+ z*J\[Sigma]3b;
rhs = Join[-IImb.Diagonal[Qb11],-IImb.Diagonal[Qb21]];
If[illcond,
Print["Linear solve 3 cond=",Max[SingularValueList[lhs,Tolerance->0]]/Min[SingularValueList[lhs,Tolerance->0]]];];
ans0 = LinearSolve[lhs//CME,rhs//CME];

Ab=BlockMatrix[{{id+IImb.Qb11,+IImb.Qb12},{+IImb.Qb21,id+IImb.Qb22}}];
lhs=Ab+ z*J\[Sigma]31b;
rhs = Join[-IImb.Diagonal[Qb12],-IImb.Diagonal[Qb22]];
If[illcond,
Print["Linear solve 4 cond=",Max[SingularValueList[lhs,Tolerance->0]]/Min[SingularValueList[lhs,Tolerance->0]]];];
ans1 = LinearSolve[lhs//CME,rhs//CME];


On[LinearSolve::luc];

s2={{ans0[[1]]+1,ans1[[1]]},{ans0[[n+1]],ans1[[n+1]]+1}};
(*Print[Inverse[s2].s1,Inverse[s2].ss1];*)
If[illcond,
Print[s1]];
If[illcond,
Print[s2]];
s1=Inverse[s2].s1;
(*s1=({{s2[[2,2]],-s2[[1,2]]},{-s2[[2,1]],s2[[1,1]]}}/Det[s2]).s1;*)
];
cond2;
(*Print["computing \[Rho](",w,")"];*)
s1
];


HillSG[F_,Fx_,Ft_,mu_,n_]:=Module[{c2,c1,c0,f11,f12,zz,one,f02,f01,t,A,Aold,L,P,dftx,fun,f10,f03,g00,g11,g02,g03},
Off[General::unfl];
Off[General::ovfl];
L = Pi;
P =1;
t[x_] := Tan[x/2];(*map the interval [-L,L] to R *)
zz[x_]:=ConstantArray[0.,Length[x]];
(*f11[x_]:= 2I Cos[x/2]^2;
f12[x_]:=-2I Cos[x/2]^2;
dftx[x_]=D[F[t[x]],x];
f02[x_]:= -I (-dftx[x]/2)/.Underflow[]\[Rule]0;
f01[x_]:= I (dftx[x]/2)/.Underflow[]\[Rule]0;
fun= {{{zz,f11},{f02,zz}},{{f01,zz},{zz,f12}}};
Aold= Hill[mu,L,n,P,fun];*)

one[x_]:=ConstantArray[-1.,Length[x]];
f10[x_]:=-4*I*2 Cos[x/2]^2;
f01[x_]:=-I*(Fx[t[x]]+Ft[t[x]]);
(*Print[f01[x]];*)
f02[x_]:=-Cos[F[t[x]]];
f03[x_]:=-Sin[F[t[x]]];
g00[x_]:=-I*(Fx[t[x]]+Ft[t[x]]);
g11[x_]:=4*I*2 Cos[x/2]^2;
g02[x_]:=Sin[F[t[x]]];
g03[x_]:=-Cos[F[t[x]]];
fun= {{{zz,f10},{f01,zz},{f02,zz},{f03,zz}},
	{{g00,zz},{zz,g11},{g02,zz},{g03,zz}},
	{{one,zz},{zz,zz},{zz,zz},{zz,zz}},
	{{zz,zz},{one,zz},{zz,zz},{zz,zz}}
};
A= Hill[mu,L,n,P,fun];
On[General::unfl];
On[General::ovfl];
Eigenvalues[Chop[A,$MachineEpsilon]]
];
LocatePolesSG[F_,Fx_,Ft_,mu_,n_]:=Module[{eval,s,i,sys,vecs},
Off[General::unfl];
eval=HillSG[F,Fx,Ft,mu,n];
s = {};
For[i=1,i<=Length[eval],i++,
If[Im[eval[[i]]]>10^(-2)&& Abs[eval[[i]]]<30,    (*this first condition exludes the continuous spectrum(they lie on the real axis) the second condition is not very clear, maybe due to relative error, some spectra on the real axis with large magnitude may have a larger Im part*)
s=Join[s,{eval[[i]]}];
];
];
On[General::unfl];
Chop[s,$MachineEpsilon]
];


\[Theta][x_,t_][z_]:= Piecewise[{{0,z==0},{2*I/4 ((z+1/z)t+(z-1/z)x ),z!=0}}];    
exppt[x_,t_][z_]:=Piecewise[{{1,z==0},{Exp[\[Theta][x,t][z]],z!=0}}];
expmt[x_,t_][z_]:=Piecewise[{{1,z==0},{Exp[-\[Theta][x,t][z]],z!=0}}];

rb[k_]:= cc[r[cc[k]]];
rbsamp[k_]:= cc[rsamp[cc[k]]];
\[Tau]samp[k_]:=1+ rsamp[k]cc[rsamp[cc[k]]];


L[x_,t_][k_]:=({
 {1, 0},
 {r[k]/\[Tau][k] exppt[x,t][k], 1}
});
Lsamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k]/\[Tau]samp[k] exppt[x,t][k], 1}
});

Lin[x_,t_][k_]:=({
 {1, 0},
 {-(r[k]/\[Tau][k])exppt[x,t][k], 1}
});
Linsamp[x_,t_][k_]:=({
 {1, 0},
 {-(rsamp[k]/\[Tau]samp[k])exppt[x,t][k], 1}
});


U[x_,t_][k_]:=({
 {1, rb[k]/\[Tau][k] expmt[x,t][k]},
 {0, 1}
});
Uin[x_,t_][k_]:=({
 {1, -(rb[k]/\[Tau][k])expmt[x,t][k]},
 {0, 1}
});
Usamp[x_,t_][k_]:=({
 {1, rbsamp[k]/\[Tau]samp[k] expmt[x,t][k]},
 {0, 1}
});
Uinsamp[x_,t_][k_]:=({
 {1, -(rbsamp[k]/\[Tau]samp[k])expmt[x,t][k]},
 {0, 1}
});

DD[k_]:=({
 {\[Tau][k], 0},
 {0, 1/\[Tau][k]}
});

DDsamp[k_]:=({
 {\[Tau]samp[k], 0},
 {0, 1/\[Tau]samp[k]}
});

G[x_,t_][z_]:=({
 {1+r[z]rb[z], rb[z]expmt[x,t][z]},
 {r[z] exppt[x,t][z], 1}
});
G[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});

(*for the samp, we actually need abs
   nope  the above is wrong,  it was because exppt and expmt were incrrectly set to zero*)

Gsamp[x_,t_][z_]:=({
 {1+rsamp[z]rbsamp[z], rbsamp[z]expmt[x,t][z]},
 {rsamp[z]  exppt[x,t][z], 1}
});
Gsamp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});


M[x_,t_][k_]:=({
 {1, rb[k] expmt[x,t][k]},
 {0, 1}
});
Msamp[x_,t_][k_]:=({
 {1, rbsamp[k] expmt[x,t][k]},
 {0, 1}
});
Minv[x_,t_][k_]:=({
 {1, -rb[k] expmt[x,t][k]},
 {0, 1}
});
Minvsamp[x_,t_][k_]:=({
 {1, -rbsamp[k] expmt[x,t][k]},
 {0, 1}
});
P[x_,t_][k_]:=({
 {1, 0},
 {r[k] exppt[x,t][k], 1}
});
Psamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k] exppt[x,t][k], 1}
});

qq[x_,t_][k_]:=Module[{out,i},
out = 1;
For[i=1,i<=Length[a],i++,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
out = out*(k-a[[i]])/(k-Conjugate[a[[i]]]);
];
];
out];
Q[x_,t_][k_]:=({
 {qq[x,t][k], 0},
 {0, 1/qq[x,t][k]}
});
Q[x_,t_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});


J[0][x_,t_]:={{G[x,t][#]&,G[x,t][#]&,G[x,t][#]&,G[x,t][#]&},{Line[{-el,-0.3}],Line[{-0.3,0.}],Line[{0,0.3}],Line[{0.3,el}]},{bigN,bigN,bigN,bigN}};
Jsamp[0][x_,t_]:={{Gsamp[x,t][#]&,Gsamp[x,t][#]&,Gsamp[x,t][#]&,Gsamp[x,t][#]&},{Line[{-el,-0.3}],Line[{-0.3,0.}],Line[{0,0.3}],Line[{0.3,el}]},{bigN,bigN,bigN,bigN}};
Jadapt[0][x_,t_]:=Adapt[Jsamp[0][x,t],globalTol][J[0][x,t]];


(* Using Arc, problems with center and radius
J[1][x_,t_]:={{M[x,t][#]&,M[x,t][#]&,M[x,t][#]&,M[x,t][#]&,P[x,t][#]&,P[x,t][#]&,P[x,t][#]&,P[x,t][#]&},{Line[{-el-I*\[Nu],-\[Nu]-I*\[Nu]}],Arc[0-I*\[Nu],\[Nu],{ \[Pi],  \[Pi]/2}],Arc[0-I*\[Nu],\[Nu],{  \[Pi]/2,0}],Line[{\[Nu]-I*\[Nu],el-I*\[Nu]}],Line[{-el+I*\[Nu],-\[Nu]+I*\[Nu]}],Arc[0+I*\[Nu],\[Nu],{ \[Pi], \[Pi]+ \[Pi]/2}],Arc[0+I*\[Nu],\[Nu],{ \[Pi]+ \[Pi]/2, 2\[Pi]}],Line[{\[Nu]+I*\[Nu],el+I*\[Nu]}]},{bigN,smallN*3,smallN*3,bigN,bigN,smallN*3,smallN*3,bigN}};
Jsamp[1][x_,t_]:={{Msamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&},{Line[{-el-I*\[Nu],-\[Nu]-I*\[Nu]}],Arc[0-I*\[Nu],\[Nu],{ \[Pi],  \[Pi]/2}],Arc[0-I*\[Nu],\[Nu],{  \[Pi]/2,0}],Line[{\[Nu]-I*\[Nu],el-I*\[Nu]}],Line[{-el+I*\[Nu],-\[Nu]+I*\[Nu]}],Arc[0+I*\[Nu],\[Nu],{ \[Pi], \[Pi]+ \[Pi]/2}],Arc[0+I*\[Nu],\[Nu],{ \[Pi]+ \[Pi]/2, 2\[Pi]}],Line[{\[Nu]+I*\[Nu],el+I*\[Nu]}]},{bigN,smallN*3,smallN*3,bigN,bigN,smallN*3,smallN*3,bigN}};
(*Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]];*)
Jadapt[1][x_,t_]:= J[1][x,t];*)

(* Using Line*)
nu1=Sqrt[1/(8\[Nu])^2-(1/(8\[Nu])-\[Nu])^2];
J[1][x_,t_]:={{M[x,t][#]&,M[x,t][#]&,M[x,t][#]&,M[x,t][#]&,P[x,t][#]&,P[x,t][#]&,P[x,t][#]&,P[x,t][#]&},{Line[{-el-I*\[Nu],-nu1-I*\[Nu]}],Line[{-nu1-I*\[Nu],0}],Line[{ 0,nu1-I*\[Nu]}],Line[{nu1-I*\[Nu],el-I*\[Nu]}],Line[{-el+I*\[Nu],-nu1+I*\[Nu]}],Line[{-nu1+I*\[Nu],0}],Line[{ 0,nu1+I*\[Nu]}],Line[{nu1+I*\[Nu],el+I*\[Nu]}]},{bigN,bigN,bigN,bigN,bigN,bigN,bigN,bigN}};
Jsamp[1][x_,t_]:={{Msamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&},{Line[{-el-I*\[Nu],-nu1-I*\[Nu]}],Line[{-nu1-I*\[Nu],0}],Line[{ 0,nu1-I*\[Nu]}],Line[{nu1-I*\[Nu],el-I*\[Nu]}],Line[{-el+I*\[Nu],-nu1+I*\[Nu]}],Line[{-nu1+I*\[Nu],0}],Line[{ 0,nu1+I*\[Nu]}],Line[{nu1+I*\[Nu],el+I*\[Nu]}]},{bigN,bigN,bigN,bigN,bigN,bigN,bigN,bigN}};
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]];
(*Jadapt[1][x_,t_]:=J[1][x,t];*)


(*Modified from NLS.nb large time*)
DDI[x_,t_][k_]:=If[Im[k] >=0,DD[x,t][k],IdentityMatrix[2]];
startift[]:=Module[{},
Clear[ift1];
ift1:=ift1=Fun[Log[\[Tau][#]]&,{-el,-0.5}//Line,bigN]; 
Clear[ift2];
ift2:=ift2=Fun[Log[\[Tau][#]]&,{-0.5,0}//Line,bigN]; 
Clear[ift3];
ift3:=ift3=Fun[Log[\[Tau][#]]&,{0,0.5}//Line,bigN]; 
Clear[ift4];
ift4:=ift4=Fun[Log[\[Tau][#]]&,{0.5,el}//Line,bigN]; 
];
(*ift here is not inverse Fourier transform*)
startift[];
(*t5=Timing[ift1=Fun[Log[\[Tau][#]]&,{-el,-0.5}//Line,bigN];
ift2=Fun[Log[\[Tau][#]]&,{-0.5,0}//Line,bigN];
ift3=Fun[Log[\[Tau][#]]&,{0,0.5}//Line,bigN];
ift4=Fun[Log[\[Tau][#]]&,{0.5,el}//Line,bigN];];*)

\[Delta]t[s_,k_]:=Exp[(Cauchy[s,ift1,k]+Cauchy[s,ift2,k]+Cauchy[s,ift3,k]+Cauchy[s,ift4,k])];
(*s=+1 left limit of Cauchy transform s=-1 right limit of Cauchy transform*)
\[Delta]t[k_]:=\[Delta]t[k]=Exp[(Cauchy[ift1,k]+Cauchy[ift2,k]+Cauchy[ift3,k]+Cauchy[ift4,k])];
\[CapitalPhi]t[z__]:=({
 {\[Delta]t[z], 0},
 {0, 1/\[Delta]t[z]}
});
\[CapitalPhi]tin[z__]:=({
 {1/\[Delta]t[z], 0},
 {0, \[Delta]t[z]}
});
(*this is for scaled version*)
\[CapitalPhi]ts[x_,t_][z_]:=\[CapitalPhi]t[x,t][z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]tins[x_,t_][z_]:=\[CapitalPhi]tin[x,t][z/Sqrt[t]-x/(4 t)];
MaxRads[x_,t_]:={Min[Sqrt[2]\[Nu] *Sqrt[t],100],Min[Sqrt[2]\[Nu] *Sqrt[t]/2,1]};

(* Using Line*)
nu1=Sqrt[1/(8\[Nu])^2-(1/(8\[Nu])-\[Nu])^2];
J[2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]t[#].L[x,t][#].\[CapitalPhi]tin[#]&,
\[CapitalPhi]t[#].L[x,t][#].\[CapitalPhi]tin[#]&,
\[CapitalPhi]t[#].L[x,t][#].\[CapitalPhi]tin[#]&,
\[CapitalPhi]t[#].L[x,t][#].\[CapitalPhi]tin[#]&,
\[CapitalPhi]t[#].U[x,t][#].\[CapitalPhi]tin[#]&,
\[CapitalPhi]t[#].U[x,t][#].\[CapitalPhi]tin[#]&,
\[CapitalPhi]t[#].U[x,t][#].\[CapitalPhi]tin[#]&,
\[CapitalPhi]t[#].U[x,t][#].\[CapitalPhi]tin[#]&
};
Domains={
Line[{-el-I*\[Nu],-nu1-I*\[Nu]}],
Line[{-nu1-I*\[Nu],0}],
Line[{ 0,nu1-I*\[Nu]}],
Line[{nu1-I*\[Nu],el-I*\[Nu]}],
Line[{-el+I*\[Nu],-nu1+I*\[Nu]}],
Line[{-nu1+I*\[Nu],0}],
Line[{ 0,nu1+I*\[Nu]}],
Line[{nu1+I*\[Nu],el+I*\[Nu]}]
};
NumPts=Table[bigN,{i,1,8}];
{Jumps,Domains,NumPts}
];
Jsamp[2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Usamp[x,t][#]&,
Usamp[x,t][#]&,
Usamp[x,t][#]&,
Usamp[x,t][#]&
};
Domains={
Line[{-el-I*\[Nu],-nu1-I*\[Nu]}],
Line[{-nu1-I*\[Nu],0}],
Line[{ 0,nu1-I*\[Nu]}],
Line[{nu1-I*\[Nu],el-I*\[Nu]}],
Line[{-el+I*\[Nu],-nu1+I*\[Nu]}],
Line[{-nu1+I*\[Nu],0}],
Line[{ 0,nu1+I*\[Nu]}],
Line[{nu1+I*\[Nu],el+I*\[Nu]}]
};
NumPts=Table[bigN,{i,1,8}];
{Jumps,Domains,NumPts}
];


Jadapt[2][x_,t_]:=Adapt[Jsamp[2][x,t],globalTol][J[2][x,t]];
(*Jadapt[2][x_,t_]:=J[2][x,t];*)1


(*
Modk0[x_,t_]:=If[t < 10*$MachineEpsilon,-Sign[x]*el/2,-Sign[x]*Min[Abs[x/(4t)],el/2]];
(*initialization cell   and    +-modk0 in small time contour*)
SmallTimeContour[x_,t_]:={Line[{-el + I \[Nu],Sqrt[2]\[Nu] Exp[I 3 Pi/4]}](*U part1*),Line[{Sqrt[2]\[Nu] Exp[I 3 Pi/4],0}](*U part2*),
Line[{-el,0}](*D*),
Line[{-el - I \[Nu],Sqrt[2]\[Nu] Exp[I 5 Pi/4]}](*L part1*),
Line[{Sqrt[2]\[Nu] Exp[I 5 Pi/4],0}](*L part2*),
Line[{0,Sqrt[2]\[Nu] Exp[I Pi/4]}](*p part2*),
Line[{Sqrt[2]\[Nu] Exp[I Pi/4],I \[Nu] + el}](*p part 1 *),
Line[{0,Sqrt[2]\[Nu] Exp[-I Pi/4]}](*m part2*),
Line[{Sqrt[2]\[Nu] Exp[-I Pi/4],-I \[Nu] + el}]}(*m part 1 *);
(*This smallTimeContour is centered at the origin right now*) 
(*if t is small, return +-100
  if t is large, return smaller one of x/4t and 100
if t is too small x/t will be too far away and do not affect too much, therefore put the deformation at z=+-100 is ok
*)
J[1][x_,t_]:={{U[x,t][#]&,U[x,t][#]&,
DD[#]&,L[x,t][#]&,L[x,t][#]&,P[x,t][#]&,P[x,t][#]&,M[x,t][#]&,M[x,t][#]&}, SmallTimeContour[x,t] + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
Jsamp[1][x_,t_]:={{Usamp[x,t][#]&,Usamp[x,t][#]&, 
DDsamp[#]&,Lsamp[x,t][#]&,Lsamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&}, SmallTimeContour[x,t] + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
(* old code not useful, seems to create only parts need to be truncated
Jsamp[1][x_,t_]:=
If[Abs[K0[x,t]]<\[Infinity],{Join[Table[Psamp[x,t][#]&,{i,1,Length[c1[x,t]]}],Table[Msamp[x,t][#]&,{i,1,Length[c1[x,t]]}]],Join[c1[x,t],c1[x,t]//LineConjugate],Table[bigN,{i,1,2*Length[c1[x,t]]}]}
,
{{Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&},{Line[{-el ,0}+I \[Nu]],Line[{0,el}+I \[Nu]],Line[{-el ,0}-I \[Nu]],Line[{0 ,el}-I \[Nu]]},{bigN,bigN,bigN,bigN}}
];*)
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]];
(*Try to break the contour at z\[Equal]0
SmallTimeContour={Line[{-el + I \[Nu],Sqrt[2]\[Nu] Exp[I 3 Pi/4]}](*U part1*),Line[{Sqrt[2]\[Nu] Exp[I 3 Pi/4],0}](*U part2*),
Line[{-el,0}](*D*),
Line[{-el - I \[Nu],Sqrt[2]\[Nu] Exp[I 5 Pi/4]}](*L part1*),
Line[{Sqrt[2]\[Nu] Exp[I 5 Pi/4],0}](*L part2*),
Line[{0,Sqrt[2]\[Nu] Exp[I Pi/4]}](*p part2*),
Line[{Sqrt[2]\[Nu] Exp[I Pi/4],I \[Nu] + el}](*p part1*),
Line[{0,Sqrt[2]\[Nu] Exp[-I Pi/4]}](*m part2*),
Line[{Sqrt[2]\[Nu] Exp[-I Pi/4],-I \[Nu] + el}]}(*m part1*);
(*This smallTimeContour is centered at the origin right now*) 
Modk0[x_,t_]:=If[t < 10*$MachineEpsilon,-Sign[x]*el/2,-Sign[x]*Min[Abs[x/(4t)],el/2]];
(*if t is small, return +-100
  if t is large, return smaller one of x/4t and 100
if t is too small x/t will be too far away and do not affect too much, therefore put the deformation at z=+-100 is ok
*)

J[1][x_,t_]:={{U[x,t][#]&,U[x,t][#]&,
DD[#]&,L[x,t][#]&,L[x,t][#]&,P[x,t][#]&,P[x,t][#]&,M[x,t][#]&,M[x,t][#]&}, SmallTimeContour + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};

Jsamp[1][x_,t_]:={{Usamp[x,t][#]&,Usamp[x,t][#]&,
DDsamp[#]&,Lsamp[x,t][#]&,Lsamp[x,t][#]&,Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&}, SmallTimeContour + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
(* old code not useful, seems to create only parts need to be truncated
Jsamp[1][x_,t_]:=
If[Abs[K0[x,t]]<\[Infinity],{Join[Table[Psamp[x,t][#]&,{i,1,Length[c1[x,t]]}],Table[Msamp[x,t][#]&,{i,1,Length[c1[x,t]]}]],Join[c1[x,t],c1[x,t]//LineConjugate],Table[bigN,{i,1,2*Length[c1[x,t]]}]}
,
{{Psamp[x,t][#]&,Psamp[x,t][#]&,Msamp[x,t][#]&,Msamp[x,t][#]&},{Line[{-el ,0}+I \[Nu]],Line[{0,el}+I \[Nu]],Line[{-el ,0}-I \[Nu]],Line[{0 ,el}-I \[Nu]]},{bigN,bigN,bigN,bigN}}
];*)
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]];*)

*)


(*InvScale[x_,t_][k_]:=Sqrt[t](k+x/(4t));*)
T[+1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {-c Exp[\[Theta][x,t][a]]/(z-a), 1}
});
T[-1][x_,t_,a_,c_][z_]:=({
 {1,  cc[-c Exp[\[Theta][x,t][a]]/(cc[z]-a)]},
 { 0, 1}
});
S[+1][x_,t_,a_,c_][z_]:=({
 {1, -(z-a)/c*Exp[-\[Theta][x,t][a]]},
 {0, 1}
});
S[-1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 { cc[-(cc[z]-a)/c*Exp[-\[Theta][x,t][a]]], 1}
});
ContourArray[+1,r_,a_]:={Arc[a,r,{0,Pi}],Arc[a,r,{Pi,2Pi}]};
ContourArray[-1,r_,a_]:={Arc[a//cc,r,{0,-Pi}],Arc[a//cc,r,{-Pi,-2Pi}]};


(*changed PoleList to PoleListn, cause this is the one called in the Add Poles part*)
PoleListn[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[a],i++,
(*why do we need upper bound? or even the lower bound: ans: to cut the contour off*)
If[1/globalTol>Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]&&Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> globalTol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{S[+1][x,t,a[[i]],c[[i]]],S[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{S[-1][x,t,a[[i]],c[[i]]],S[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";,
Jumps = Join[Jumps,{T[+1][x,t,a[[i]],c[[i]]],T[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{T[-1][x,t,a[[i]],c[[i]]],T[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArray[+1,rad,a[[i]]],ContourArray[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];


DomainIntegrate[0.]:=0;
tcrit=8;
SG[i_][x_,t_]:=Module[{rhp1,rhp2,scale,\[CapitalPhi]1,\[CapitalPhi]2,\[CapitalPhi],out,t1,t2,t3,t4,poles,pl},
If[i==3,scale=True,scale=False];
RHSolved//Clear;
RHSolved[X_]:=RHSolved[X]=RHSolve[X];
RHSolution[X_][z_]:=Cauchy[X//RHSolved,z]+IdentityMatrix[2];
(*Q is V in the book*)
If[scale,
(*Scaled contour*)
t1=AbsoluteTiming[rhp1=ConjugateList[Jadapt[i][x,t],Q[x,t]]//MakeListFun;];
t2=AbsoluteTiming[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][InvScale[x,t][k]]//Inverse;
,
(*Unscaled contour*)
(*Print["rhp1 unscaled constructing"];*)
t1=Timing[rhp1=ConjugateList[Jadapt[i][x,t],Q[x,t]]//MakeListFun;];
domainOutput = DomainPlot[rhp1];
Grhp1=rhp1;
(*Print["rhp1 unscaled constructed"];*)
t2=Timing[RHSolved[rhp1];];
(*Print["rhp1 unscaled solved"];*)
\[CapitalPhi]1[k_]:=RHSolution[rhp1][k]//Inverse;
];
\[CapitalPhi][k_]:=RHSolution[rhp1][k];
(*Print["rhp1 solved"];*)
pl=PoleListn[x,t];
(*Print[pl];*)
t3={0};
t4={0};
If[Length[pl[[1]]]>0,
rhp2= ConjugateList[pl,Q[x,t]];
(*Print["checking polelist at x =",x,", t =",t," and PoleListn[x,t]=",PoleListn[x,t]];*)
(*pl is not given any value, \[CapitalPhi]tin is the delta in the book*)
If[i==3,
rhp2= ConjugateList[rhp2,\[CapitalPhi]tin[x,t]];
];
t3=Timing[rhp2= ConjugateList[rhp2,\[CapitalPhi]1]//MakeListFun;];
Grhp2=rhp2;
t4=Timing[RHSolved[rhp2];];
\[CapitalPhi]2 = RHSolution[rhp2];
\[CapitalPhi][k_]:=RHSolution[rhp2][k].RHSolution[rhp1][k];
];
(*out=-(DomainIntegrate[RHSolved[rhp1]]+DomainIntegrate[RHSolved[rhp2]])[[1,2]]/Pi;*)
(*out=\[CapitalPhi][0.000000000001I].P[x,t][0];*)
out=\[CapitalPhi][0.000000000001I].{{1,0},{0,-1}}.Inverse[\[CapitalPhi][0.000000000001I]];
(*domainOutput = DomainPlot[Join[rhp1,rhp2]]//Quiet;*)
domainOutput2 = DomainPlot[rhp2]//Quiet;
timestring= "Region: " <>ToString[i]<>" ("<>ToString[N[x]]<>","<>ToString[N[t]]<>") "<>"1) Construct: " <> ToString[t1//First]<>"  "<>"1) Solve: " <> ToString[t2//First]<>"  "<>"2) Construct: " <> ToString[t3//First]<>"  "<>"2) Solve: " <> ToString[t4//First];
If[timeflag,Print[timestring];];
{out,\[CapitalPhi],rhp1,rhp2,timestring}
];
SGAuto[x_,t_]:=Piecewise[{{SG[0][x,t][[1]],Abs[x]<Abs[t]}(*region 0*),
						{SG[1][x,t][[1]],x>=t }(*region 1*),
						{SG[2][x,t][[1]],x<=-t }}(*region 2*),
						SG[0][x,t][[1]](*region 0*)]



End[];
